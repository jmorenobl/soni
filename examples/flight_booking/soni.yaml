# Soni Framework Configuration
# Version: 0.1
# This file defines a complete configuration for a flight booking dialogue system
#
# Schema Structure:
# - version: Required string indicating the configuration schema version
# - settings: Global configuration for models, persistence, and logging
# - flows: Dialogue flows with procedural steps (supports branching and jumps)
# - slots: Entity definitions that need to be collected from users
# - actions: External action handlers with input/output contracts
#
# Features:
# - Branching logic and conditional routing (v0.3.0+)
# - Explicit jumps between steps (v0.3.0+)
# - Validator Registry with semantic names (v0.4.0+)
# - Action Registry with auto-discovery (v0.4.0+)
# - Zero-Leakage Architecture: YAML describes WHAT, Python implements HOW (v0.4.0+)

# Configuration schema version (required)
# Must be a string. Current version is "0.1"
version: "0.1"

# Global settings for models, persistence, logging, etc.
# All fields in settings are optional with sensible defaults
settings:
  # NLU model configuration
  # Defines which language model to use for dialogue understanding
  models:
    nlu:
      # Provider: "openai", "anthropic", etc. (required if models.nlu is present)
      provider: openai
      # Model identifier: specific model name from the provider
      # Examples: "gpt-4o-mini", "gpt-4", "claude-3-haiku"
      model: gpt-4o-mini
      # Temperature: controls randomness (0.0 = deterministic, 1.0 = creative)
      # Range: 0.0 to 2.0, recommended: 0.1-0.3 for dialogue understanding
      temperature: 0.1

  # Persistence configuration
  # Defines how dialogue state is persisted across turns
  persistence:
    # Backend: "sqlite" (development), "postgres" (production), "redis" (production)
    # Required if persistence is present
    backend: sqlite
    # Path: file path for SQLite, connection string for Postgres/Redis
    # For SQLite: relative or absolute path to .db file
    path: ./dialogue_state.db

  # Logging configuration
  # Controls logging verbosity and tracing
  logging:
    # Level: "DEBUG", "INFO", "WARNING", "ERROR"
    # Default: "INFO"
    level: INFO
    # Trace graphs: whether to log full graph execution traces
    # Default: false (set to true for debugging)
    trace_graphs: false

# Dialogue flows - procedural steps for complex flows
# Each flow defines a sequence of steps that guide the conversation
# Supports linear flows, branching, and conditional jumps (v0.3.0+)
flows:
  # Flow name: unique identifier for this flow
  book_flight:
    # Description: human-readable description of what this flow does
    description: "Book a flight from origin to destination"

    # Trigger: defines when this flow should be activated
    trigger:
      # Intents: natural language phrase examples that trigger this flow
      # Used for NLU optimization - the LLM learns to map these phrases to the flow name
      intents:
        - "I want to book a flight"
        - "Book me a flight"
        - "I need to reserve a flight"
        - "Can I book a flight?"

    # Steps: ordered list of steps to execute in sequence
    # Each step has a unique name, type, and type-specific configuration
    steps:
      # Step 1: Collect origin slot value from user
      - step: collect_origin
        # Type: "collect" - prompts user for a slot value
        type: collect
        # Slot: name of the slot to collect (must be defined in slots section)
        slot: origin
        # Prompt: optional custom prompt (uses slot prompt if not specified)
        prompt: "Where would you like to fly from?"

      # Step 2: Collect destination slot
      - step: collect_destination
        type: collect
        slot: destination
        prompt: "Where would you like to fly to?"

      # Step 3: Collect departure date
      - step: collect_date
        type: collect
        slot: departure_date
        prompt: "When would you like to depart?"

      # Step 4: Search for available flights
      - step: search_flights
        # Type: "action" - calls an external handler
        type: action
        # Call: name of the action to execute (must be defined in actions section)
        call: search_available_flights
        # Map outputs: maps action outputs to flat state variables
        # Format: {state_variable: action_output_field}
        # This decouples internal data structures from the flow definition
        map_outputs:
          flights: flights
          price: price

      # Step 5: Confirm booking
      - step: confirm_booking
        type: action
        call: confirm_flight_booking
        map_outputs:
          booking_ref: booking_ref
          confirmation: confirmation

# Slot definitions - entities that need to be collected from users
# Slots represent structured information extracted from natural language
slots:
  # Slot name: unique identifier used in flows
  origin:
    # Type: data type of the slot value
    # Supported types: "string", "integer", "float", "boolean", "date"
    type: string
    # Prompt: question to ask user when this slot is missing
    # Used by the collect step to request the value
    prompt: "Which city are you departing from?"
    # Required: whether this slot must be collected before flow completion
    # Default: false
    required: true
    # Validator: name of validator to use (must be registered in ValidatorRegistry)
    # Validators are semantic names (e.g., "city_name") not regex patterns
    # Zero-Leakage Architecture: validation logic lives in Python, not YAML (v0.4.0+)
    validator: city_name

  destination:
    type: string
    prompt: "Where would you like to go?"
    required: true
    validator: city_name

  departure_date:
    type: string
    prompt: "What is your departure date?"
    required: true
    validator: future_date_only

# Action definitions - external handlers that perform business logic
# Actions are decoupled from implementation: YAML defines contracts, Python implements
# This allows changing implementation without modifying YAML (Zero-Leakage architecture)
actions:
  # Action name: unique identifier used in flow steps
  search_available_flights:
    # Description: human-readable description of what this action does
    description: "Search for available flights between origin and destination"

    # Handler removed - registered in handlers.py using @ActionRegistry.register()
    # Import handlers.py to auto-register actions

    # Inputs: list of slot names that this action requires
    # These slots must be collected before this action can execute
    # The runtime will pass these as keyword arguments to the handler
    inputs:
      - origin
      - destination
      - departure_date

    # Outputs: list of output field names this action produces
    # These are used by map_outputs in flow steps
    # The handler should return a dict with these keys
    outputs:
      - flights
      - price

  confirm_flight_booking:
    description: "Confirm flight booking and generate booking reference"
    # Handler removed - registered in handlers.py using @ActionRegistry.register()
    # Import handlers.py to auto-register actions
    inputs:
      - flights
      - origin
      - destination
      - departure_date
    outputs:
      - booking_ref
      - confirmation
