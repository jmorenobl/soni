"""Command Executor for Soni v2.0.

This module implements the deterministic execution of commands generated by the NLU.
It acts as the bridge between NLU intention (Command) and DM state changes.
"""

import logging
from typing import Any, cast

from soni.core.commands import (
    Command,
    SetSlot,
    StartFlow,
)
from soni.core.constants import ConversationState
from soni.core.patterns.defaults import register_default_patterns
from soni.core.patterns.registry import PatternRegistry
from soni.core.types import DialogueState, RuntimeContext

logger = logging.getLogger(__name__)

# Ensure defaults are registered
if not PatternRegistry.get_all():
    register_default_patterns()


async def execute_commands_node(state: DialogueState, context: RuntimeContext) -> dict[str, Any]:
    """LangGraph node for executing a list of commands.

    Args:
        state: Current dialogue state
        context: Runtime dependencies

    Returns:
        State updates (merged into global state)
    """
    commands: list[Command] = state.get("command_log", [])
    if not commands:
        logger.info("No commands to execute.")
        return {}

    logger.info(f"Executing {len(commands)} commands: {[str(c) for c in commands]}")

    # Track updates to return
    updates: dict[str, Any] = {}

    for command in commands:
        # 1. specific handling based on command type
        cmd_updates = await _execute_single_command(command, state, context)
        updates.update(cmd_updates)

        # Apply updates immediately to local 'state' view for subsequent commands
        # (simulating sequential execution context)
        cast(dict[str, Any], state).update(cmd_updates)

    return updates


async def _execute_single_command(
    command: Command, state: DialogueState, context: RuntimeContext
) -> dict[str, Any]:
    """Execute a single command."""

    # 1. Check for Pattern overriding first
    # Iterate through all registered patterns to see if any match the command
    for pattern in PatternRegistry.get_all():
        if pattern.matches(command, state):
            logger.info(f"Command {command.__class__.__name__} matched pattern '{pattern.name}'")
            return await pattern.handle(command, state, context)

    # 2. Standard Command Execution (Default Handlers)

    if isinstance(command, StartFlow):
        # Push new flow
        # Logic: flow_manager.push_flow(command.flow_name)
        # We assume flow_manager is available in context
        if context["flow_manager"]:
            # This is a simplification; in real impl we'd call flow_manager methods
            # For now, we return state updates that effectively start the flow
            logger.info(f"Starting flow: {command.flow_name}")
            # Real impl would involve updating flow_stack
            return {"conversation_state": ConversationState.UNDERSTANDING}  # Placeholder

    elif isinstance(command, SetSlot):
        logger.info(f"Setting slot {command.slot_name} = {command.value}")
        # Update flow_slots in state
        # In a real impl, we'd merge this into the deeply nested flow_slots dict
        return {}

    # AffirmConfirmation is now handled by ConfirmationPattern
    # elif isinstance(command, AffirmConfirmation):
    #    return {"conversation_state": ConversationState.READY_FOR_ACTION}

    return {}
