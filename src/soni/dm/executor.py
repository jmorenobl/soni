"""Command Executor for Soni v2.0.

This module implements the deterministic execution of commands generated by the NLU.
It acts as the bridge between NLU intention (Command) and DM state changes.
"""

import logging
from typing import Any, cast

from soni.core.commands import (
    Command,
    SetSlot,
    StartFlow,
)
from soni.core.constants import ConversationState
from soni.core.patterns.defaults import register_default_patterns
from soni.core.patterns.registry import PatternRegistry
from soni.core.types import DialogueState, NodeRuntime, RuntimeContext

logger = logging.getLogger(__name__)

# Ensure defaults are registered
if not PatternRegistry.get_all():
    register_default_patterns()


async def execute_commands_node(state: DialogueState, runtime: NodeRuntime) -> dict[str, Any]:
    """LangGraph node for executing a list of commands.

    Args:
        state: Current dialogue state
        runtime: Runtime context with dependencies

    Returns:
        State updates (merged into global state)
    """
    commands: list[Command] = state.get("command_log", [])
    if not commands:
        logger.info("No commands to execute. Defaulting to fallback response.")
        # FIX: Prevent infinite loop if NLU returned no commands (e.g. "hmm", "maybe")
        # Return generating_response so the turn ends and the user sees the fallback message
        return {
            "conversation_state": ConversationState.GENERATING_RESPONSE,
            "last_response": "I didn't understand that. Could you rephrase?",
        }

    logger.info(f"Executing {len(commands)} commands: {[str(c) for c in commands]}")

    # Track updates to return
    updates: dict[str, Any] = {}
    context = runtime.context  # Extract RuntimeContext from NodeRuntime wrapper

    for command in commands:
        # 1. specific handling based on command type
        cmd_updates = await _execute_single_command(command, state, context)
        updates.update(cmd_updates)

        # Apply updates immediately to local 'state' view for subsequent commands
        # (simulating sequential execution context)
        cast(dict[str, Any], state).update(cmd_updates)

    return updates


async def _execute_single_command(
    command: Command, state: DialogueState, context: RuntimeContext
) -> dict[str, Any]:
    """Execute a single command."""

    # 1. Check for Pattern overriding first
    # Iterate through all registered patterns to see if any match the command
    for pattern in PatternRegistry.get_all():
        if pattern.matches(command, state):
            logger.info(f"Command {command.__class__.__name__} matched pattern '{pattern.name}'")
            return await pattern.handle(command, state, context)

    # 2. Standard Command Execution (Default Handlers)

    if isinstance(command, StartFlow):
        # Push new flow
        flow_manager = context.get("flow_manager")
        if flow_manager:
            try:
                flow_manager.push_flow(
                    state,
                    flow_name=command.flow_name,
                    inputs=command.slots,
                    reason="nlu_command",
                )
                logger.info(f"Started flow: {command.flow_name} with inputs: {command.slots}")
                return {
                    "conversation_state": ConversationState.UNDERSTANDING,
                    "flow_stack": state["flow_stack"],  # Persist modified stack
                    "flow_slots": state["flow_slots"],  # Persist modified slots
                }
            except Exception as e:
                logger.error(f"Failed to start flow {command.flow_name}: {e}")
                return {}

    elif isinstance(command, SetSlot):
        flow_manager = context.get("flow_manager")
        if flow_manager:
            try:
                flow_manager.set_slot(state, slot_name=command.slot_name, value=command.value)
                logger.info(f"Set slot {command.slot_name} = {command.value}")
                return {
                    "flow_slots": state["flow_slots"],  # Persist modified slots
                    "flow_stack": state["flow_stack"],  # Persist modified stack (ensure it exists)
                }
            except Exception as e:
                logger.error(f"Failed to set slot {command.slot_name}: {e}")
                return {}

    # AffirmConfirmation is now handled by ConfirmationPattern
    # elif isinstance(command, AffirmConfirmation):
    #    return {"conversation_state": ConversationState.READY_FOR_ACTION}

    return {}
